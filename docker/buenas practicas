춰Hola! Hace tiempo que trabajo con Docker. La creaci칩n de Dockerfiles es una parte esencial del proceso, y quer칤a compartir algunos consejos sobre c칩mo mejorarlo.

Los objetivos:
Queremos minimizar el tama침o de la imagen, el tiempo de compilaci칩n y el n칰mero de capas.
Queremos maximizar el uso de la cach칠 de compilaci칩n y la legibilidad del Dockerfile.
Queremos que trabajar con nuestro contenedor sea lo m치s agradable posible.
TL;DR - Para los que tienen prisa
Este art칤culo est치 lleno de ejemplos y descripciones detalladas, as칤 que, aqu칤 tienes un resumen r치pido:

Escribir archivo .dockerignore
El contenedor debe hacer una sola cosa
춰Debemos entender el almacenamiento en cach칠 de Docker! Usa los comandos COPY y RUN en el orden correcto a la hora de utilizarlo.
Fusionar varios comandos RUN en uno solo.
Eliminar archivos innecesarios despu칠s de cada paso.
Usar una imagen base adecuada (las versiones Alpine deber칤an ser suficientes)
Configurar WORKDIR y CMD
Utilizar ENTRYPOINT cuando se tenga m치s de un comando y/o se necesite actualizar archivos usando datos en tiempo de ejecuci칩n.
Usar exec dentro del script del punto de entrada.
Mejor usar COPY que ADD
Especificar variables de entorno, puertos y vol칰menes predeterminados dentro de Dockerfile
Ejemplo pr치ctico
As칤 que, acabas de leer mis consejos. 춰Todo genial...! Pero te preguntar치s, 쯖칩mo introducirlos en mis Dockerfiles y en qu칠 se notar치 el hacerlo?

He preparado un peque침o archivo Dockerfile, con casi todos los posibles errores que se me ocurren. Ahora lo arreglaremos. Supongamos que queremos dockerizar una peque침a aplicaci칩n web Node.js. Aqu칤 est치 (es complicada y probablemente no funcione, pero es tan s칩lo un ejemplo):

FROM ubuntu 

ADD . /app 

RUN apt-get update RUN apt-get upgrade -y 
RUN apt-get install -y nodejs ssh mysql 
RUN cd /app && npm install 

# esto deber칤a iniciar tres procesos, mysql y ssh 
# en segundo plano y node app en primer plano 
# no es tremendamente bonito? <3 
CMD mysql & sshd & npm start
Podr칤amos construirlo usando docker build -t wtf.

쯇uedes detectar todos los errores que tiene? 쯅o? Vamos a arreglarlos juntos, uno por uno.

1. Escribir .dockerignore
Al crear una imagen, Docker debe preparar el context antes de nada: recopilar todos los archivos que se pueden utilizar en un proceso. El contexto predeterminado contiene todos los archivos de un directorio Dockerfile. Normalmente no queremos incluir ah칤 el directorio .git, las bibliotecas descargadas ni los archivos compilados. El archivo .dockerignore es exactamente igual a .gitignore, por ejemplo:

.git/ 
node_modules/ 
dist/
2. El contenedor debe hacer una sola cosa
T칠cnicamente, PUEDES iniciar m칰ltiples procesos dentro de un contenedor Docker. PUEDES poner aplicaciones de base de datos, frontend y backend, ssh, y supervisor en una imagen de docker. Pero muchas cosas no te ir치n bien:

Los tiempos de compilaci칩n ser치n largos (un cambio en, por ejemplo, el frontend te obligar치 a volver a compilar todo el backend)
Las im치genes ser치n muy grandes
Tendr치s un registro duro de datos desde muchas aplicaciones (no un simple stdout)
Escalado horizontal innecesario
Problemas con los procesos "zombies" - Tendr치s que acordarte de cu치l es el proceso init adecuado
Mi consejo es que prepares una imagen Docker separada para cada componente y que utilices Docker Compose para iniciar f치cilmente varios contenedores al mismo tiempo.

Eliminemos los paquetes innecesarios de nuestro Dockerfile. SSH puede ser reemplazado por docker exec.

FROM ubuntu 

ADD . /app 

RUN apt-get update
RUN apt-get upgrade -y
  
# deber칤amos quitar ssh y mysql, y usar 
# contenedor separado para la base de datos  
RUN apt-get install -y nodejs # ssh mysql 
RUN cd /app && npm install 

CMD npm start
3. Fusionar varios comandos RUN en uno solo
Docker est치 totalmente basado en capas. El conocimiento de c칩mo funcionan es esencial.

Cada comando en Dockerfile crea una capa.
Las capas se almacenan en cach칠 y se reutilizan.
Invalidar la cach칠 de una sola capa invalida todas las capas subsiguientes.
La invalidaci칩n ocurre despu칠s de un cambio de comando, si los archivos copiados son diferentes, o si la variable de compilaci칩n es diferente a la anterior.
Las capas son inmutables, as칤 que, si a침adimos un archivo a una capa y lo eliminamos en la siguiente, la imagen TODAV칈A contiene ese archivo (춰simplemente no estar치 disponible en el contenedor!)
Me gusta comparar las im치genes de Docker con una cebolla:

Imagen de una cebolla - Dominio P칰blico

Las dos te hacen llorar... esto no :) Ambas tienen capas. Para acceder y modificar la capa interna, debes eliminar todas las anteriores. Recuerda esto y todo ir치 bien.

Vamos a optimizar nuestro ejemplo. Estamos fusionando todos los comandos RUN en uno, y eliminando la actualizaci칩n apt-get, ya que hace que nuestra compilaci칩n no sea determinista (dependemos de las actualizaciones de nuestra imagen base):

FROM ubuntu 

ADD . /app 

RUN apt-get update \ 
    && apt-get install -y nodejs \ 
    && cd /app \ 
	&& npm install 
	
CMD npm start
Se debe tener en cuenta que se deben fusionar comandos que tienen una probabilidad similar de ser modificados o de sufrir cambios. Actualmente, cada vez que nuestro c칩digo fuente se modifique, necesitamos reinstalar Node.js por completo. As칤 que, una opci칩n mejor es:

FROM ubuntu 

RUN apt-get update && apt-get install -y nodejs 
ADD . /app 
RUN cd /app && npm install 

CMD npm start
4. No utilices la etiqueta de imagen base latest
La etiqueta latest es la que se utiliza por defecto, cuando no se especifica ninguna otra etiqueta. As칤 que nuestra instrucci칩n FROM ubuntu en realidad hace exactamente lo mismo que FROM ubuntu:latest. Pero la etiqueta latest apuntar치 a una imagen diferente cuando se publique una nueva versi칩n, y tu build puede romperse. Por lo tanto, a menos que est칠s creando un Dockerfile gen칠rico que tengas que estar actualizado con la imagen base, deber치s proporcionar una etiqueta espec칤fica.

En nuestro ejemplo, usemos la etiqueta 16.04:

FROM ubuntu:16.04 # 춰es as칤 de f치cil! 

RUN apt-get update && apt-get install -y nodejs 
ADD . /app 
RUN cd /app && npm install 

CMD npm start
5. Eliminar archivos innecesarios despu칠s de cada paso de RUN
Por lo tanto, supongamos que hemos actualizado las fuentes apt-get, instalado algunos paquetes necesarios para compilar otros, y hemos descargado y extra칤do los archivos. Obviamente no los necesitamos en nuestras im치genes finales, as칤 que, mejor hagamos una limpieza. 춰El tama침o importa!

En nuestro ejemplo podemos eliminar las listas apt-get (creadas por apt-get update):

FROM ubuntu:16.04
 
RUN apt-get update \ 
	&& apt-get install -y nodejs \ 
    # l칤neas a침adidas 
    && rm -rf /var/lib/apt/lists/* 
    
ADD . /app 
RUN cd /app && npm install

CMD npm start
6. Usar una imagen base adecuada
En nuestro ejemplo estamos usando ubuntu. Pero, 쯣or qu칠? Realmente necesitamos una imagen de base de prop칩sito general, cuando s칩lo queremos ejecutar una aplicaci칩n de Node.js? Una mejor opci칩n es usar una imagen especializada con Node.js ya instalado:

FROM node ADD . /app 

# ya no se necesita instalar
# node ni usar apt-get 
RUN cd /app && npm install 

CMD npm start
O mejor a칰n, podemos elegir la versi칩n Alpine (Alpine es una distribuci칩n Linux muy peque침a, de unos 4 MB de tama침o. Esto lo convierte en el candidato perfecto para una imagen base)

FROM node:7-alpine 

ADD . /app 
RUN cd /app  && npm install 

CMD npm start
Alpine tiene un gestor de paquetes, llamado apk. Es un poco diferente a apt-get, pero a칰n as칤 es bastante f치cil de aprender. Adem치s, tiene algunas caracter칤sticas realmente 칰tiles, como las opciones --o-cache y --virtual. De esta manera, elegimos exactamente lo que queremos en nuestra imagen, nada m치s. Tu disco te va a amar :)

7. Configurar WORKDIR y CMD
El comando WORKDIR cambia el directorio por defecto, donde ejecutamos nuestros comandos RUN / CMD / ENTRYPOINT.

CMD es una ejecuci칩n de comandos por defecto despu칠s de crear un contenedor sin otro comando especificado. Por lo general, es la acci칩n que se realiza con m치s frecuencia. A침ad치moslos a nuestro Dockerfile:

FROM node:7-alpine 

WORKDIR /app 
ADD . /app 
RUN npm install 

CMD ["npm", "start"]
Debes poner tu comando dentro de la matriz, una palabra por elemento (m치s en la documentaci칩n oficial)

8. Usa ENTRYPOINT (opcional)
No siempre es necesario, es opcional, ya que Entrypoint, o punto de entrada, a침ade complejidad. 쮺칩mo funciona este sistema?

Entrypoint es un script, que se ejecutar치 en lugar de un determinado comando, y recibir치 칠ste como un argumento. Es una excelente forma de crear im치genes ejecutables Docker:

#!/usr/bin/env sh
# $0 is a script name, 
# $1, $2, $3 etc are passed arguments  # $1 is our command 
CMD=$1
  
case "$CMD" in  
    "dev" ) 
		npm install 
		export NODE_ENV=development 
		exec npm run dev 
		;;
		
	"start" ) 
	# we can modify files here, using ENV variables passed in 
	# "docker create" command. It can't be done during build process.  
	echo  "db: $DATABASE_ADDRESS" >> /app/config.yml 
	export NODE_ENV=production 
	exec npm start 
	;;

	* ) 
	 # Run custom command. Thanks to this line we can still use 
	 # "docker run our_image /bin/bash" and it will work  
	 exec $CMD ${@:2} 
	 ;; 
esac
Gu치rdalo en tu directorio ra칤z, con el nombre entrypoint.sh. As칤 es su uso en Dockerfile:

FROM node:7-alpine 

WORKDIR /app 
ADD . /app 
RUN npm install 

ENTRYPOINT ["./entrypoint.sh"] 
CMD ["start"]
Ahora, valga la redundancia, podemos ejecutar esta imagen en un formato ejecutable:

docker run nuestra-app dev
docker run nuestra-app start

docker run -it nuestra-app /bin/bash` # Este tambi칠n funcionar치.
9. Usar exec dentro del script entrypoint
Como puedes ver en el ejemplo de entrypoint, estamos usando exec. Sin 칠l, no podr칤amos detener nuestra aplicaci칩n de forma elegante (SIGTERM es engullido por el script bash). Exec b치sicamente reemplaza el proceso de script con uno nuevo, por lo que todas las se침ales y c칩digos de salida funcionan como se hab칤a previsto.

10. Mejor COPY que ADD
COPY es m치s sencillo. ADD tiene cierta l칩gica para descargar archivos remotos y extraer archivos (m치s en la documentaci칩n oficial). S칩lo tienes que quedarte con COPY.

Nota: este punto necesita una explicaci칩n adicional. ADD puede ser 칰til si la compilaci칩n depende de recursos externos y quieres que la invalidaci칩n de la cach칠 de compilaci칩n sea la adecuada en caso de cambio. No es una buena pr치ctica, pero a veces es la 칰nica manera de hacerlo.

Vamos a A칌ADIR... uups, COPIAR esto en nuestro ejemplo:

FROM node:7-alpine 

WORKDIR /app 

COPY . /app 
RUN npm install 

ENTRYPOINT ["./entrypoint.sh"] 
CMD ["start"]
11. Optimizar COPY y RUN
Deber칤amos poner los cambios que se producen con menor frecuencia en la parte superior de nuestros Dockerfiles para aprovechar el almacenamiento en cach칠.

En nuestro ejemplo, el c칩digo cambiar치 a menudo, y no queremos reinstalar paquetes cada vez. Podemos copiar el package.json antes del resto del c칩digo, instalar dependencias y luego a침adir otros archivos. Apliquemos esa mejora a nuestro Dockerfile:

FROM node:7-alpine 

WORKDIR /app 

COPY package.json /app 
RUN npm install 
COPY . /app 

ENTRYPOINT ["./entrypoint.sh"] 
CMD ["start"]
12. Especificar variables de entorno, puertos y vol칰menes predeterminados
Probablemente necesitemos algunas variables de entorno para ejecutar nuestro contenedor. Es una buena pr치ctica establecer valores predeterminados en Dockerfile. Adem치s, debemos mostrar todos los puertos utilizados y definir los vol칰menes.

Haz nuestro curso de 游낾 Docker y olv칤date de decir eso de: Pues en mi equipo funciona...
Veamos la siguiente mejora aplicada a nuestro ejemplo:

FROM node:7-alpine 

# env variables required during build 
ENV PROJECT_DIR=/app 

WORKDIR $PROJECT_DIR 

COPY package.json $PROJECT_DIR 
RUN npm install 
COPY . $PROJECT_DIR
 
# env variables that can change  
# volume and port settings  
# and defaults for our application 
ENV MEDIA_DIR=/media \ 
	NODE_ENV=production \ 
	APP_PORT=3000 

VOLUME $MEDIA_DIR 
EXPOSE $APP_PORT 

ENTRYPOINT ["./entrypoint.sh"] 
CMD ["start"]
Estas variables estar치n disponibles en el contenedor. Si necesitas variables de compilaci칩n solamente, usa build args en su lugar.

13. A침adir metadatos a la imagen usando LABEL
Hay una opci칩n para a침adir metadatos a la imagen, como informaci칩n sobre qui칠n es el encargado de mantenerla o una descripci칩n ampliada. Necesitamos la instrucci칩n LABEL para ello (antes pod칤amos usar la opci칩n MAINTAINER, pero ahora est치 obsoleta). Los metadatos son utilizados a veces por programas externos, por ejemplo nvidia-docker requiere la etiqueta com.nvidia.volumes.needed para funcionar correctamente.

Ejemplo de un metadato en nuestro Dockerfile:

FROM node:7-alpine 
LABEL maintainer "jakub.skalecki@example.com" 
...
14. A침adir HEALTHCHECK
Podemos iniciar el contenedor docker con la opci칩n --restart always (reiniciar siempre). Despu칠s de un fallo del contenedor, el "demonio" de Docker intentar치 reiniciarlo. Es muy 칰til si tu contenedor tiene que estar operativo todo el tiempo. Pero, 쯤u칠 pasa si el contenedor se est치 ejecutando, pero no est치 disponible (bucle infinito, configuraci칩n no v치lida, etc.)? Con la instrucci칩n HEALTHCHECK podemos decirle a Docker que compruebe peri칩dicamente el estado de salud de nuestro contenedor. Puede ser cualquier comando, devolviendo 0 como c칩digo de salida si todo est치 bien, y 1 en el caso contrario.

칔ltimo cambio a nuestro ejemplo:

FROM node:7-alpine 
LABEL maintainer "jakub.skalecki@example.com" 

ENV PROJECT_DIR=/app 
WORKDIR $PROJECT_DIR 

COPY package.json $PROJECT_DIR 
RUN npm install 
COPY . $PROJECT_DIR 
ENV MEDIA_DIR=/media \ 
		 NODE_ENV=production \ 
		 APP_PORT=3000 

VOLUME $MEDIA_DIR 
EXPOSE $APP_PORT 
HEALTHCHECK CMD curl --fail http://localhost:$APP_PORT || exit 

ENTRYPOINT ["./entrypoint.sh"] 
CMD ["start"]
curl --fail devuelve el c칩digo de salida que no es cero si la petici칩n falla.

Para usuarios avanzados
Este post se est치 haciendo muy largo, as칤 que, aunque tenga algunas ideas m치s, no las expondr칠 aqu칤. Si quieres saber m치s, echa un vistazo a las instrucciones de STOPSIGNAL, ONBUILD y SHELL. Adem치s, algunas opciones muy 칰tiles durante la compilaci칩n son --no-cache (especialmente en un servidor de integraci칩n continua, si quiere estar seguro de que la compilaci칩n se puede hacer en una nueva instalaci칩n de Docker), y --squash (m치s aqu칤).